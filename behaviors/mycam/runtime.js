// ECMAScript 5 strict mode
"use strict";

// MyCam Behavior for Construct 2
//
// This behavior was generated by Gemini Code Assist based on user specifications.
// The logic uses common, publicly known game development algorithms (like
// framerate-independent Lerp and exponential decay for screen shake) and
// mathematical formulas that are not subject to copyright.
//
// You are free to use, modify, and distribute this code. For clarity, you can
// add your own copyright notice and apply a permissive license like the MIT License.
//
// The 'easeInOutQuad' easing function is a standard formula, widely attributed to Robert Penner.

assert2(cr, "cr namespace not created");
assert2(cr.behaviors, "cr.behaviors not created");

/////////////////////////////////////
// Behavior class
//           vvvvv
cr.behaviors.MyCam = function(runtime)
{
	this.runtime = runtime;
};

(function ()
{
	//             vvvvv
	var behaviorProto = cr.behaviors.MyCam.prototype;
		
	/////////////////////////////////////
	// Behavior type class
	behaviorProto.Type = function(behavior, objtype)
	{
		this.behavior = behavior;
		this.objtype = objtype;
		this.runtime = behavior.runtime;
	};
	
	var behtypeProto = behaviorProto.Type.prototype;

	behtypeProto.onCreate = function()
	{
	};

	/////////////////////////////////////
	// Behavior instance class
	behaviorProto.Instance = function(type, inst)
	{
		this.type = type;
		this.behavior = type.behavior;
		this.inst = inst;				// associated object instance to modify
		this.runtime = type.runtime;
	};
	
	var behinstProto = behaviorProto.Instance.prototype;

	behinstProto.onCreate = function()
	{
		// Load properties
		this.enabled = (this.properties[0] === 1);
		this.smoothness = cr.clamp(this.properties[1], 0, 1);
		this.deadzoneWidth = this.properties[2];
		this.deadzoneHeight = this.properties[3];
		this.lookAheadDistance = this.properties[4];
		this.gridSnapping = (this.properties[5] === 1);
		this.roomWidth = this.properties[6];
		this.roomHeight = this.properties[7];
		this.snapDuration = Math.max(this.properties[8], 0.001);
		this.clampToLayout = (this.properties[9] === 1);
		this.autoZoom = (this.properties[10] === 1);
		this.minScale = this.properties[11];
		this.maxScale = this.properties[12];
		this.maxSpeedForZoom = this.properties[13];
		this.zoomSpeed = cr.clamp(this.properties[14], 0, 1);
		
		// object is sealed after this call, so make sure any properties you'll ever need are created, e.g.
		// High-precision internal camera state
		this.cameraX = this.inst.x;
		this.cameraY = this.inst.y;

		// Targeting
		this.secondaryTargetUid = -1;
		this.lastHostX = this.inst.x;
		this.lastHostY = this.inst.y;

		// Panning state
		this.isPanning = false;
		this.panStartX = 0;
		this.panStartY = 0;
		this.panTargetX = 0;
		this.panTargetY = 0;
		this.panTime = 0;
		this.panDuration = 1;

		// Shaking state
		this.isShaking = false;
		this.shakeIntensity = 0;
		this.shakeTime = 0;
		this.shakeDuration = 0;
		this.shakeDecay = 0;

		// Grid snapping state
		this.isSnapping = false;
		this.snapStartX = 0;
		this.snapStartY = 0;
		this.snapTargetX = 0;
		this.snapTargetY = 0;
		this.snapTime = 0;

		// Clamping
		this.useCustomClamp = false;
		this.minX = 0;
		this.minY = 0;
		this.maxX = 0;
		this.maxY = 0;

		// Zooming
		this.currentLayerScale = this.inst.layer ? this.inst.layer.scale : 1.0;

		// First tick guard for initialization
		this.firstTick = true;

		// Ensure tick2 is called
		this.runtime.tick2Me(this);
	};
	
	behinstProto.onDestroy = function ()
	{
	};
	
	// called when saving the full state of the game
	behinstProto.saveToJSON = function ()
	{
		return {
			"en": this.enabled,
			"sm": this.smoothness,
			"dzw": this.deadzoneWidth,
			"dzh": this.deadzoneHeight,
			"la": this.lookAheadDistance,
			"gs": this.gridSnapping,
			"rw": this.roomWidth,
			"rh": this.roomHeight,
			"sd": this.snapDuration,
			"cl": this.clampToLayout,
			"az": this.autoZoom,
			"mins": this.minScale,
			"maxs": this.maxScale,
			"msz": this.maxSpeedForZoom,
			"zs": this.zoomSpeed,
			"cx": this.cameraX,
			"cy": this.cameraY,
			"stuid": this.secondaryTargetUid,
			"ucc": this.useCustomClamp,
			"cminx": this.minX, "cminy": this.minY, "cmaxx": this.maxX, "cmaxy": this.maxY
		};
	};
	
	// called when loading the full state of the game
	behinstProto.loadFromJSON = function (o)
	{
		this.enabled = o["en"];
		this.smoothness = cr.clamp(o["sm"], 0, 1);
		this.deadzoneWidth = o["dzw"];
		this.deadzoneHeight = o["dzh"];
		this.lookAheadDistance = o["la"];
		this.gridSnapping = o["gs"];
		this.roomWidth = o["rw"];
		this.roomHeight = o["rh"];
		this.snapDuration = Math.max(o["sd"], 0.001);
		this.clampToLayout = o["cl"];
		this.autoZoom = o["az"];
		this.minScale = o["mins"];
		this.maxScale = o["maxs"];
		this.maxSpeedForZoom = o["msz"];
		this.zoomSpeed = cr.clamp(o["zs"], 0, 1);
		this.cameraX = o["cx"];
		this.cameraY = o["cy"];
		this.secondaryTargetUid = o["stuid"];
		this.useCustomClamp = o["ucc"];
		this.minX = o["cminx"]; this.minY = o["cminy"]; this.maxX = o["cmaxx"]; this.maxY = o["cmaxy"];

		// When loading from a save state, it is never the first tick.
		this.firstTick = false;
	};

	behinstProto.tick = function () {
		// All logic is in tick2 to ensure it runs after the host object's final position is calculated.
	};

	function easeInOutQuad(t) {
		t /= 0.5;
		if (t < 1) return 0.5 * t * t;
		t--;
		return -0.5 * (t * (t - 2) - 1);
	};

	behinstProto.tick2 = function ()
	{
		var dt = this.runtime.getDt(this.inst);
		var inst = this.inst;
		var layer = inst.layer;

		if (!this.enabled || !layer)
			return;

		// --- First Tick Initialization Guard ---
		if (this.firstTick)
		{
			// On the very first tick, forcibly sync the camera to the instance's position.
			// This prevents any NaN issues from uninitialized state or actions called on startup.
			if (isFinite(inst.x) && isFinite(inst.y)) {
				this.cameraX = inst.x;
				this.cameraY = inst.y;
				this.lastHostX = inst.x;
				this.lastHostY = inst.y;
			}

			// If a pan was requested on startup (before this first tick), ensure its start coords are now valid.
			if (this.isPanning) {
				this.panStartX = this.cameraX;
				this.panStartY = this.cameraY;
			}
			this.firstTick = false;
		}

		if (dt === 0) return; // Do not process movement if time has not passed

		// Self-healing: If camera state is corrupted (NaN), reset to object position.
		if (!isFinite(this.cameraX) || !isFinite(this.cameraY)) {
			this.cameraX = isFinite(inst.x) ? inst.x : 0;
			this.cameraY = isFinite(inst.y) ? inst.y : 0;
		}

		// Self-healing for zoom scale
		if (!isFinite(this.currentLayerScale))
			this.currentLayerScale = 1.0;

		// --- Determine Target Position ---
		var targetX = inst.x;
		var targetY = inst.y;
		var hostSpeed = 0;

		// State: Panning overrides all tracking
		if (this.isPanning)
		{
			this.panTime += dt;
			var pan_t = this.panTime / this.panDuration;

			if (pan_t >= 1) {
				pan_t = 1;
				this.isPanning = false;
				this.cameraX = this.panTargetX;
				this.cameraY = this.panTargetY;
				this.runtime.trigger(cr.behaviors.MyCam.prototype.cnds.OnPanFinished, inst);
			} else {
				var eased_t = easeInOutQuad(pan_t);
				this.cameraX = cr.lerp(this.panStartX, this.panTargetX, eased_t);
				this.cameraY = cr.lerp(this.panStartY, this.panTargetY, eased_t);
			}
		}
		// State: Grid Snapping overrides tracking
		else if (this.isSnapping)
		{
			this.snapTime += dt;
			var snap_t = this.snapTime / this.snapDuration;

			if (snap_t >= 1) {
				snap_t = 1;
				this.isSnapping = false;
				this.cameraX = this.snapTargetX;
				this.cameraY = this.snapTargetY;
				this.runtime.trigger(cr.behaviors.MyCam.prototype.cnds.OnSnapFinished, inst);
			} else {
				var eased_snap_t = easeInOutQuad(snap_t);
				this.cameraX = cr.lerp(this.snapStartX, this.snapTargetX, eased_snap_t);
				this.cameraY = cr.lerp(this.snapStartY, this.snapTargetY, eased_snap_t);
			}
		}
		// State: Normal Tracking
		else
		{
			// Multi-Target Averaging
			var secondary = this.runtime.getObjectByUID(this.secondaryTargetUid);
			if (secondary) {
				targetX = (targetX + secondary.x) / 2;
				targetY = (targetY + secondary.y) / 2;
			}

			// Look-Ahead
			var hostVelX = (inst.x - this.lastHostX) / dt;
			var hostVelY = (inst.y - this.lastHostY) / dt;
			hostSpeed = Math.sqrt(hostVelX * hostVelX + hostVelY * hostVelY);

			// Guard against division by zero or infinity, which can result in NaN.
			if (isFinite(hostSpeed) && hostSpeed > 1) {
				targetX += (hostVelX / hostSpeed) * this.lookAheadDistance;
				targetY += (hostVelY / hostSpeed) * this.lookAheadDistance;
			}

			// Deadzone
			var dx = targetX - this.cameraX;
			var dy = targetY - this.cameraY;
			var halfDeadX = this.deadzoneWidth / 2;
			var halfDeadY = this.deadzoneHeight / 2;

			if (Math.abs(dx) > halfDeadX) {
				// Use a cross-browser compatible way to get the sign of a number.
				var sign_dx = dx > 0 ? 1 : -1;
				targetX = this.cameraX + dx - (halfDeadX * sign_dx);
			} else {
				targetX = this.cameraX;
			}

			if (Math.abs(dy) > halfDeadY) {
				var sign_dy = dy > 0 ? 1 : -1;
				targetY = this.cameraY + dy - (halfDeadY * sign_dy);
			} else {
				targetY = this.cameraY;
			}

			// Elastic Damping (Lerp)
			// This formula provides a framerate-independent interpolation.
			// 'smoothness' acts as a coefficient, where smaller values give tighter following.
			var lerpFactor = 1 - Math.pow(this.smoothness, dt);
			this.cameraX = cr.lerp(this.cameraX, targetX, lerpFactor);
			this.cameraY = cr.lerp(this.cameraY, targetY, lerpFactor);

			// Grid Snap Trigger
			if (this.gridSnapping && this.roomWidth > 0 && this.roomHeight > 0)
			{
				var camRoomX = Math.floor(this.cameraX / this.roomWidth);
				var camRoomY = Math.floor(this.cameraY / this.roomHeight);
				var hostRoomX = Math.floor(inst.x / this.roomWidth);
				var hostRoomY = Math.floor(inst.y / this.roomHeight);

				if (camRoomX !== hostRoomX || camRoomY !== hostRoomY) {
					this.isSnapping = true;
					this.snapTime = 0;
					this.snapStartX = this.cameraX;
					this.snapStartY = this.cameraY;
					this.snapTargetX = (hostRoomX * this.roomWidth) + (this.roomWidth / 2);
					this.snapTargetY = (hostRoomY * this.roomHeight) + (this.roomHeight / 2);
				}
			}
		}

		// --- Post-Processing & Final Output ---
		var finalX = this.cameraX;
		var finalY = this.cameraY;

		// Clamping
		if (this.clampToLayout || this.useCustomClamp)
		{
			var layout = inst.layer.layout;
			var viewW = layer.viewRight - layer.viewLeft;
			var viewH = layer.viewBottom - layer.viewTop;
			var minX = this.useCustomClamp ? this.minX : (viewW / 2);
			var minY = this.useCustomClamp ? this.minY : (viewH / 2);
			var maxX = this.useCustomClamp ? this.maxX : (layout.width - viewW / 2);
			var maxY = this.useCustomClamp ? this.maxY : (layout.height - viewH / 2);

			finalX = cr.clamp(finalX, minX, maxX);
			finalY = cr.clamp(finalY, minY, maxY);
		}

		// Screen Shake
		if (this.isShaking)
		{
			this.shakeTime += dt;
			if (this.shakeTime >= this.shakeDuration) {
				this.isShaking = false;
				this.runtime.trigger(cr.behaviors.MyCam.prototype.cnds.OnShakeFinished, inst);
			} else {
				var currentIntensity = this.shakeIntensity * (1 - (this.shakeTime / this.shakeDuration)); // Linear decay
				if (this.shakeDecay > 0) {
					currentIntensity = this.shakeIntensity * Math.pow(1 - this.shakeDecay, this.shakeTime); // Exponential decay
				}
				finalX += (Math.random() * 2 - 1) * currentIntensity;
				finalY += (Math.random() * 2 - 1) * currentIntensity;
			}
		}

		// Auto Zoom
		if (this.autoZoom && this.maxSpeedForZoom > 0)
		{
			var speedRatio = cr.clamp(hostSpeed / this.maxSpeedForZoom, 0, 1);
			var targetScale = cr.lerp(this.maxScale, this.minScale, speedRatio);
			var zoomLerpFactor = 1 - Math.pow(1 - this.zoomSpeed, dt * 60);
			this.currentLayerScale = cr.lerp(this.currentLayerScale, targetScale, zoomLerpFactor);
			layer.scale = this.currentLayerScale;
		}

		// Set Layer Scroll (Pixel-Perfect)
		if (isFinite(finalX) && isFinite(finalY)) {
			this.runtime.running_layout.scrollToX(Math.round(finalX));
			this.runtime.running_layout.scrollToY(Math.round(finalY));
		}

		// Update last known position for next tick's velocity calculation
		this.lastHostX = inst.x;
		this.lastHostY = inst.y;
	};
	
	// The comments around these functions ensure they are removed when exporting, since the
	// debugger code is no longer relevant after publishing.
	/**BEGIN-PREVIEWONLY**/
	behinstProto.getDebuggerValues = function (propsections)
	{
		propsections.push({
			"title": this.type.name,
			"properties": [
				{"name": "Camera X", "value": this.cameraX.toFixed(2), "readonly": true},
				{"name": "Camera Y", "value": this.cameraY.toFixed(2), "readonly": true},
				{"name": "State", "value": this.isPanning ? "Panning" : (this.isSnapping ? "Snapping" : (this.isShaking ? "Shaking" : "Tracking")), "readonly": true}
			]
		});
	};
	
	behinstProto.onDebugValueEdited = function (header, name, value)
	{
	};
	/**END-PREVIEWONLY**/

	//////////////////////////////////////
	// Conditions
	function Cnds() {};

	Cnds.prototype.IsMoving = function () {
		return this.isPanning || this.isSnapping;
	};
	Cnds.prototype.IsShaking = function () { return this.isShaking; };
	Cnds.prototype.IsPanning = function () { return this.isPanning; };
	Cnds.prototype.OnShakeFinished = function () { return true; };
	Cnds.prototype.OnPanFinished = function () { return true; };
	Cnds.prototype.OnSnapFinished = function () { return true; };
	
	behaviorProto.cnds = new Cnds();

	//////////////////////////////////////
	// Actions
	function Acts() {};

	Acts.prototype.SetEnabled = function (e) {
		this.enabled = (e === 1);
	};

	Acts.prototype.SetSecondaryTarget = function (obj) {
		if (!obj) return;
		var inst = obj.getFirstPicked(this.inst);
		if (inst)
			this.secondaryTargetUid = inst.uid;
	};

	Acts.prototype.ClearSecondaryTarget = function () {
		this.secondaryTargetUid = -1;
	};

	Acts.prototype.PanToPosition = function (x, y, duration) {
		if (!isFinite(x) || !isFinite(y)) return;

		this.isPanning = true;
		this.panStartX = isFinite(this.cameraX) ? this.cameraX : (isFinite(this.inst.x) ? this.inst.x : 0);
		this.panStartY = isFinite(this.cameraY) ? this.cameraY : (isFinite(this.inst.y) ? this.inst.y : 0);
		this.panTargetX = x;
		this.panTargetY = y;
		this.panDuration = Math.max(duration, 0.001);
		this.panTime = 0;
	};

	Acts.prototype.TriggerShake = function (intensity, duration, decay) {
		this.isShaking = true;
		this.shakeIntensity = intensity;
		this.shakeDuration = Math.max(duration, 0.001);
		this.shakeDecay = cr.clamp(decay, 0, 1);
		this.shakeTime = 0;
	};

	Acts.prototype.SetCustomClamping = function (minX, minY, maxX, maxY) {
		this.useCustomClamp = true;
		this.clampToLayout = false;
		this.minX = minX;
		this.minY = minY;
		this.maxX = maxX;
		this.maxY = maxY;
	};

	Acts.prototype.SetClampToLayout = function () {
		this.useCustomClamp = false;
		this.clampToLayout = true;
	};

	Acts.prototype.SetSmoothness = function (s) {
		this.smoothness = cr.clamp(s, 0, 1);
	};

	Acts.prototype.SetDeadzone = function (w, h) {
		this.deadzoneWidth = w;
		this.deadzoneHeight = h;
	};

	Acts.prototype.SetLookAhead = function (d) {
		this.lookAheadDistance = d;
	};

	Acts.prototype.SetGridSnapping = function (s) {
		this.gridSnapping = (s === 1);
	};
	
	behaviorProto.acts = new Acts();

	//////////////////////////////////////
	// Expressions
	function Exps() {};
	
	Exps.prototype.CameraX = function (ret) {
		ret.set_float(this.cameraX);
	};
	Exps.prototype.CameraY = function (ret) {
		ret.set_float(this.cameraY);
	};
	Exps.prototype.ShakeIntensity = function (ret) {
		var intensity = 0;
		if (this.isShaking) {
			intensity = this.shakeIntensity * (1 - (this.shakeTime / this.shakeDuration));
		}
		ret.set_float(intensity);
	};
	Exps.prototype.CurrentScale = function (ret) {
		ret.set_float(this.inst.layer ? this.inst.layer.scale : 1.0);
	};
	
	behaviorProto.exps = new Exps();
	
}());